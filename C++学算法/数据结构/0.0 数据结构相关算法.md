# 1. 线性表
- [ ] 列表
- [ ] 链表
- [ ] 跳跃表
- [ 1] 并查集？？
# 2. 栈与队列
- [ ] 栈
- [ ] 队列
- [ ] 优先队列、*堆*
- [ ] 多级反馈队列??
# 3. Hash表
- [ ] 碰撞解决办法：开放定址法、链地址法、再次hash法、建立公共溢出区
- [ ] *布隆过滤器*
1. hash键的设计，即构造value(传入参数)到key(返回参数)的映射函数
2. 双指针(滑动窗口)可以不利用hash_map,利用hash_map(unoredered_map)减少查找元素时间复杂度，利用map可以自动排序(据说utilize红黑树)

# 4. 树
- [ ] 二叉树的遍历（递归与非递归）
- [x] **Hoffman树与编码**~二叉搜索树
- [x] **AVL树？？**（平衡二叉树，左右旋）
- [ ] B树(多路，插入与删除)与B+树(可返回)
- [ ] **前缀树？？**：字典树
- [ ] 红黑树
- [ ] **线段树？？**
# 5. 数组
- [ ] 树状数组？？
- [ ] 矩阵
### 查找按照对象的不同

链表、队列、栈等线性结构——折半查找》插值查找》斐波那契查找...

树——二叉搜索/排序树，AVL树，Huffman树

hash_table——hash映射，桶内查找

# Conventional Algorithm
# 1. 排序算法
- [ ] 简单排序：插入、选择、冒泡
- [ ] 分治：快速、归并
- [ ] 分配：桶排序？？、基数排序？？
- [ ] 树状：堆排序
- [ ] additional: 计数？？、希尔
# 2. Graph Theory
- [ ] 存储：邻接矩阵/表
- [ ] traverse: DFS&&BFS
- [ ] 最短路径： **Floyd,Dihkstra**
- [ ] 最小生成树：**Prim,Kruskal**
- [ ] 常用算法：关键路径、拓扑排序(剪枝)
# 3. 搜索与回溯
- [ ] 贪心算法
- [ ] 启发式搜索算法：A*寻路
- [ ] 地图着色、
- [ ] N皇后
- [ ] 最右加工顺序
- [ ] 旅行商
# 4. Dynamic Plan
- [ ] 树形DP??：01背包？？
- [ ] 线性：最长公共子串、子序列
- [ ] 区间：矩阵最大值（和&积）
- [ ] 数位：数字游戏？？
- [ ] 状态压缩DP：旅行商
# 5. 字符串匹配
- [ ] **正则表达式**
- [x] **KMP**
- [ ] Boyer-Moore??



give curious thought:

1. 递归数组法就是动态规划
2. 分治算法=分类讨论
3. 动态规划n+1时要比较(n+1Un的子集的所有选择)∪n时的最优选择;
   贪心只要做出第n+1个的选择,~~就能得到n+1时最优解~~

